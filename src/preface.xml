<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE preface>

<preface    xml:id="preface"
            xmlns="http://docbook.org/ns/docbook"
            xmlns:xl="http://www.w3.org/1999/xlink"
            xmlns:xi="http://www.w3.org/2001/XInclude"
            xmlns:ns5="http://www.w3.org/1998/Math/MathML"
            xmlns:ns4="http://www.w3.org/1999/xhtml"
            xmlns:ns3="http://www.w3.org/2000/svg"
            xmlns:ns="http://docbook.org/ns/docbook">
<title>前言</title>

<sect1 xml:id="purpose"><title>本文目的</title>
    <para>本文目的在于，将自己的C#库crifanLib.cs中的函数都详细解释一遍</para>
    <para>以方便，看了我的库函数，知道如何使用。</para>
</sect1>

<sect1 xml:id="whatis_crifanlib_cs"><title>crifanLib.cs的由来</title>
    <para>之前在折腾<link xl:href="http://www.crifan.com/crifan_released_all/website/dotnet/wlw_plugin_insertskydrivefiles/">WLW (Windows Live Writer) Plugin–InsertSkydriveFiles</link>的过程中，先后遇到很多个问题，然后基本上也都自己解决了。对应的也写了相应的代码和函数。</para>
    <para>后来又折腾了很多其他C#方面的东西，比如：</para>
    <para><link xl:href="http://www.crifan.com/crifan_released_all/website/dotnet/downloadsongtastemusic/">downloadSonstasteMusic(下载Songtaste歌曲)</link></para>
    <para>前前后后，就把其中比较常用或通用的功能，整理提取出来，放到一个单独的文件中，即<filename>crifanLib.cs</filename></para>
    <para>此文就是专门针对每个函数，进行详细的解释其用法和给出示例。</para>
</sect1>

<sect1 xml:id="download_crifanlib_cs"><title>最新最全的crifanLib.cs完整代码下载</title>
    <para>该文件，之前以帖子的方式发布到这里的：<link xl:href="http://www.crifan.com/crifan_csharp_lib_crifanlib_cs/">crifan的C#函数库：crifanLib.cs</link></para>
    <para>后来，就放到Google Code上去了，即：</para>
    <para>所有的，完整的<filename>crifanLib.cs</filename>的内容，都是：</para>
    <itemizedlist>
        <listitem>会不定期更新</listitem>
        <listitem>最新版本始终都放在<link xl:href="http://code.google.com/p/crifanlib/">google code中的crifanLib</link>中的<link xl:href="http://code.google.com/p/crifanlib/source/browse/trunk/csharp/crifanLib.cs">crifanLib.cs</link>了，需要的，自己去下载即可。</listitem>
    </itemizedlist>
    <para>其中，当前，截止到2013-08-20，<filename>crifanLib.cs</filename>的最新版本是：</para>
</sect1>


<sect1 xml:id="crifanlib_cs_using"><title>crifanLib.cs所包含的引用（using）</title>
    <para>如果你在使用这些函数的遇到说某某函数，类等找不到，那很可能是没有包含对应的此处的引用。</para>
    <para>那么则请自行参考<filename>crifanLib.cs</filename>中的using部分，添加对应的引用。</para>
    <sect2 xml:id="crifanlib_cs_macro"><title>crifanLib.cs中的宏定义</title>
        <para>经过后来的版本升级，此时的<filename>crifanLib.cs</filename>中，已经包含了很多宏定义。</para>
        <para>这些宏定义，主要用于，打开，关闭，某些库函数的，以便实现：</para>
        <para>当你不想要使用某些函数，以及其会依赖到相关的库，的时候，则可以直接注释掉对应的宏，以实现此目的。</para>
        <para>举例，比如，你此处，不想用.NET是3.5或更高的版本，也不想要使用JSON相关的函数，则可以在<filename>crifanLib.cs</filename>中，把JSON的宏注释掉，即：</para>
        <programlisting language="csharp">
//#define USE_JSON
        </programlisting>
        <para>如此，就不会使用到JSON相关的函数了：此刻的效果，主要是：</para>
        <itemizedlist>
            <listitem>相关的函数jsonToDict等被注释掉</listitem>
            <listitem>不需要用到（json所依赖的）.NET 3.5+才有的库：System.Web.Script.Serialization了
            <programlisting language="csharp">
#if USE_JSON
using System.Web.Script.Serialization; // json lib, need: .NET 3.5+
#endif
            </programlisting>
            </listitem>
        </itemizedlist>
    </sect2>
   
    <sect2 xml:id="crifanlib_cs_all_using"><title>crifanLib.cs中引用的所有的库</title>
        <para>此处，就把<filename>crifanLib.cs</filename>目前所有依赖的库，即所有的using，都贴出来，供需要的人，自己添加自己所需要的：</para>
        <programlisting language="csharp">
<![CDATA[
//comment out following macros if not use them
#define USE_GETURLRESPONSE_BW //for getUrlResponse use backgroundworker version
//#define USE_HTML_PARSER_SGML //need SgmlReaderDll.dll
//#define USE_HTML_PARSER_HTMLAGILITYPACK //need HtmlAgilityPack.dll
//#define USE_DATAGRIDVIEW
//#define USE_JSON


using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Web; // for server
using System.Net; // for client
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Drawing;
using System.Windows.Forms;
using System.Reflection;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;

#if USE_JSON
using System.Web.Script.Serialization; // json lib, need: .NET 3.5+
#endif

#if USE_HTML_PARSER_SGML
using Sgml;
using System.Xml;
#endif

#if USE_HTML_PARSER_HTMLAGILITYPACK
using HtmlAgilityPack;
#endif

#if USE_DATAGRIDVIEW
using Excel = Microsoft.Office.Interop.Excel;
using Microsoft.Office.Interop.Excel;
#endif
]]>
        </programlisting>
        <para></para>
    </sect2>
    
    <sect2 xml:id="crifanlib_cs_macro_explain"><title>crifanLib.cs中各个宏的解释</title>
        <para>如上所述，<filename>crifanLib.cs</filename>中包含了一些宏，用于控制一些相关的功能，是否使用。</para>
        <para>此处，就对于这些宏，进行详细的解释：</para>
        <sect3 xml:id="use_geturlresponse_bw"><title>USE_GETURLRESPONSE_BW</title>
            <para>默认关闭此宏。</para>
            <para>其背景是：</para>
            <para>原先的getUrlResponse，是用于获得URL的响应，属于耗时操作，其在C#中使用时，一般都是出于默认的UI进程中。</para>
            <para>导致结果是：当调用到getUrlResponse（以及相关的getUrlRespHtml等）函数时，UI失去响应，导致用户体验很不好。</para>
            <para>所以后来又实现了一个BackgroundWorker版本的getUrlResponse</para>
            <para>使得，当调用getUrlResponse，UI也可以得到响应了。</para>
            <para></para>
            <para>所以，如果你想要用BackgroundWorker版本的getUrlResponse，就可以打开此宏：</para>
            <programlisting language="csharp">
#define USE_GETURLRESPONSE_BW //for getUrlResponse use backgroundworker version
            </programlisting>
            <para>如果没此需求，就关闭此宏：</para>
            <programlisting language="csharp">
//#define USE_GETURLRESPONSE_BW //for getUrlResponse use backgroundworker version
            </programlisting>
        </sect3>
        
        <sect3 xml:id="sgml_or_htmlagilitypack"><title>USE_HTML_PARSER_SGML和USE_HTML_PARSER_HTMLAGILITYPACK</title>
            <para>之前解析HTML，最初用的就是这个sgml库：SgmlReaderDll.dll</para>
            <para>但是明显不是很好用。</para>
            <para>后来发现了另外一个库：HtmlAgilityPack.dll，后，发现比较好用，就更多的时候，都用HtmlAgilityPack.dll这个库了。</para>
            <para>所以，推荐做法：</para>
            <para>当涉及到HTMl解析的时候，推荐用HtmlAgilityPack，不太推荐用Sgml</para>
            <para>所以，一般设置为：</para>
            <programlisting language="csharp">
//#define USE_HTML_PARSER_SGML //need SgmlReaderDll.dll
#define USE_HTML_PARSER_HTMLAGILITYPACK //need HtmlAgilityPack.dll
            </programlisting>
            <para>即可。</para>
            <para>当然，如果你两个库都使用，也是可以的。</para>
            <note xml:id="note.html_parser_lib"><title>使用sgml或HtmlAgilityPack时要有对应的dll库</title>
                <para>此处很明显，当使用对应的库时，则必须有对应的dll库文件，即</para>
                <itemizedlist>
                    <listitem>SgmlReaderDll.dll
                        <para>详见：<link xl:href="http://www.crifan.com/record_csharp_html_parser/">【记录】C#中的HTML解析</link></para>
                    </listitem>
                    <listitem>HtmlAgilityPack.dll
                        <para>详见：<link xl:href="http://www.crifan.com/csharp_play_with_html_parse_htmlaglitypack/">【记录】折腾C#中的HTML解析库：HtmlAglityPack</link></para>
                    </listitem>
                </itemizedlist>
            </note>
        </sect3>
                
        <sect3 xml:id="use_datagridview"><title>USE_DATAGRIDVIEW</title>
            <para>DataGridView是表格控件。</para>
            <para>之前的很多折腾：</para>
            <itemizedlist>
                <listitem><link xl:href="http://www.crifan.com/summary_how_to_use_csharp_datagridview/">【整理】如何使用C#中的DataGridView控件</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_export_datagridview_to_csv/">【已解决】C#中DataGridView中的数据导出为CSV</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_clear_all_datagridview_data/">【已解决】C#中，清除DataGridView中已有的数据</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_datagridview_add_event_for_datagridviewbuttoncell/">【已解决】给C#的DataGridView中的DataGridViewButtonCell添加事件</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_datagridview_select_newly_added_row/">【已解决】C#的DataGridView中，如何选中新添加的行</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_datagridview_add_whole_button_column_in_cell/">【已解决】C#的DataGridView中的单元格内添加按钮（整列都是按钮）</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_datagridview_auto_add_line_number_on_row_head/">【已解决】C#的DataGridView中自动在行首添加行号</link></listitem>
                <listitem><link xl:href="http://www.crifan.com/csharp_datagridview_save_export_data_to_csv_or_excel/">【已解决】将C#中的DataGridView中的数据，导出为Excel</link></listitem>
                <listitem></listitem>
            </itemizedlist>
            <para>整理出了这些函数：</para>
            <itemizedlist>
                <listitem>dgvClearContent</listitem>
                <listitem>dgvDrawHeaderNum</listitem>
                <listitem>releaseObject</listitem>
                <listitem>dgvExportToExcel</listitem>
                <listitem>dgvExportToCsv</listitem>
            </itemizedlist>
            <para>所以，当你需要的时候，可以打开此宏：</para>
            <programlisting language="csharp">
#define USE_DATAGRIDVIEW
            </programlisting>
            <para>去使用相关函数。</para>
        </sect3>
        
        <sect3 xml:id="use_json"><title>USE_JSON</title>
            <para>可以去开启JSON的宏：</para>
            <programlisting language="csharp">
#define USE_JSON
            </programlisting>
            <para>以去使用对应的函数：</para>
            <itemizedlist>
                <listitem>jsonToDict</listitem>
            </itemizedlist>
            <note xml:id="note.json_need_v3.5_dotnet"><title>json需要.NET 3.5+版本</title>
                <para>json依赖的库是：System.Web.Script.Serialization，是需要.NET 3.5或更高的版本才可以的。</para>
                <para>换句话说，如果你当前C#项目是2.0的，那么需要转为3.5或更高版本的，才可以用此JSON函数。</para>
            </note>
        </sect3>

    </sect2>
</sect1>

<sect1 xml:id="crifanlib_cs_global_private"><title>crifanLib.cs中的全局变量，初始化代码，私有函数</title>
    <para>此处，顺便也把对应的，全局变量，初始化代码，私有函数等等，贴出来，供参考：</para>
    <programlisting language="csharp">
<![CDATA[
    public struct pairItem
    {
        public string key;
        public string value;
    };

    private Dictionary<string, DateTime> calcTimeList;

    const char replacedChar = '_';

    string[] cookieFieldArr = { "expires", "domain", "secure", "path", "httponly", "version" };

    //IE7
    const string constUserAgent_IE7_x64 = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E)";
    //IE8
    const string constUserAgent_IE8_x64 = "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.3; .NET4.0C; .NET4.0E";
    //IE9
    const string constUserAgent_IE9_x64 = "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)"; // x64
    const string constUserAgent_IE9_x86 = "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)"; // x86
    //Chrome
    const string constUserAgent_Chrome = "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/533.4 (KHTML, like Gecko) Chrome/5.0.375.99 Safari/533.4";
    //Mozilla Firefox
    const string constUserAgent_Firefox = "Mozilla/5.0 (Windows; U; Windows NT 6.1; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6";
    private string gUserAgent;

    private WebProxy gProxy = null;

    //detault values:
    //getUrlResponse
    private const Dictionary<string, string> defHeaderDict = null;
    private const Dictionary<string, string> defPostDict = null;
    private const int defTimeout = 30 * 1000;
    private const string defPostDataStr = null;
    private const int defReadWriteTimeout = 30 * 1000;
    //getUrlRespHtml 
    private const string defCharset = null;
    //getUrlRespHtml_multiTry
    private const int defMaxTryNum = 5;
    private const int defRetryFailSleepTime = 100; //sleep time in ms when retry fail for getUrlRespHtml

    List<string> cookieFieldList = new List<string>();

    CookieCollection curCookies = null;

    //private long totalLength = 0;
    //private long currentLength = 0;
#if USE_GETURLRESPONSE_BW
    //indicate background worker complete or not
    bool bNotCompleted_resp = true;
    //store response of http request
    private HttpWebResponse gCurResp = null;
#endif

    private BackgroundWorker gBgwDownload;
    //indicate download complete or not
    bool bNotCompleted_download = true;
    //store current read out data len
    private int gRealReadoutLen = 0;
    Action<int> gFuncUpdateProgress = null;

    public crifanLib()
    {
        //!!! for load embedded dll: (1) register resovle handler
        AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CurrentDomain_AssemblyResolve);

        //http related
        gUserAgent = constUserAgent_IE8_x64;
        //set max enough to avoid http request is used out -> avoid dead while get response 
        System.Net.ServicePointManager.DefaultConnectionLimit = 200;

        curCookies = new CookieCollection();
        // init const cookie keys
        foreach (string key in cookieFieldArr)
        {
            cookieFieldList.Add(key);
        }

        //init for calc time
        calcTimeList = new Dictionary<string, DateTime>();
#if USE_GETURLRESPONSE_BW
        gBgwDownload = new BackgroundWorker();
#endif

        //debug
        //gProxy = new WebProxy("127.0.0.1", 8087);
    }

    /*------------------------Private Functions------------------------------*/

    //!!! for load embedded dll: (2) implement this handler
    System.Reflection.Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
    {
        string dllName = args.Name.Contains(",") ? args.Name.Substring(0, args.Name.IndexOf(',')) : args.Name.Replace(".dll", "");

        dllName = dllName.Replace(".", "_");

        if (dllName.EndsWith("_resources")) return null;

        System.Resources.ResourceManager rm = new System.Resources.ResourceManager(GetType().Namespace + ".Properties.Resources", System.Reflection.Assembly.GetExecutingAssembly());

        byte[] bytes = (byte[])rm.GetObject(dllName);

        return System.Reflection.Assembly.Load(bytes);
    }

    // replace the replacedChar back to original ','
    private string _recoverExpireField(Match foundPprocessedExpire)
    {
        string recovedStr = "";
        recovedStr = foundPprocessedExpire.Value.Replace(replacedChar, ',');
        return recovedStr;
    }

    //replace ',' with replacedChar
    private string _processExpireField(Match foundExpire)
    {
        string replacedComma = "";
        replacedComma = foundExpire.Value.ToString().Replace(',', replacedChar);
        return replacedComma;
    }

    //replace "0A" (in \x0A) into '\n'
    private string _replaceEscapeSequenceToChar(Match foundEscapeSequence)
    {
        char[] hexValues = new char[2];
        //string hexChars = foundEscapeSequence.Value.ToString();
        string matchedEscape = foundEscapeSequence.ToString();
        hexValues[0] = matchedEscape[2];
        hexValues[1] = matchedEscape[3];
        string hexValueString = new string(hexValues);
        int convertedInt = int.Parse(hexValueString, NumberStyles.HexNumber, NumberFormatInfo.InvariantInfo);
        char hexChar = Convert.ToChar(convertedInt);
        string hexStr = hexChar.ToString();
        return hexStr;
    }
    
    //check whether need add/retain this cookie
    // not add for:
    // ck is null or ck name is null
    // domain is null and curDomain is not set
    // expired and retainExpiredCookie==false
    private bool needAddThisCookie(Cookie ck, string curDomain)
    {
        bool needAdd = false;

        if ((ck == null) || (ck.Name == ""))
        {
            needAdd = false;
        }
        else
        {
            if (ck.Domain != "")
            {
                needAdd = true;
            }
            else// ck.Domain == ""
            {
                if (curDomain != "")
                {
                    ck.Domain = curDomain;
                    needAdd = true;
                }
                else // curDomain == ""
                {
                    // not set current domain, omit this
                    // should not add empty domain cookie, for this will lead execute CookieContainer.Add() fail !!!
                    needAdd = false;
                }
            }
        }

        return needAdd;
    }

    //quote the input dict values
    //note: the return result for first para no '&'
    private string _quoteParas(Dictionary<string, string> paras, bool spaceToPercent20 = true)
    {
        string quotedParas = "";
        bool isFirst = true;
        string val = "";
        foreach (string para in paras.Keys)
        {
            if (paras.TryGetValue(para, out val))
            {
                string encodedVal = "";
                if (spaceToPercent20)
                {
                    //encodedVal = HttpUtility.UrlPathEncode(val);
                    //encodedVal = Uri.EscapeDataString(val);
                    //encodedVal = Uri.EscapeUriString(val);
                    encodedVal = HttpUtility.UrlEncode(val).Replace("+", "%20");
                }
                else
                {
                    encodedVal = HttpUtility.UrlEncode(val); //space to +
                }

                if (isFirst)
                {
                    isFirst = false;
                    quotedParas += para + "=" + encodedVal;
                }
                else
                {
                    quotedParas += "&" + para + "=" + encodedVal;
                }
            }
            else
            {
                break;
            }
        }

        return quotedParas;
    }

    /* get url's response
     * */
    private HttpWebResponse _getUrlResponse(string url,
                                    Dictionary<string, string> headerDict = defHeaderDict,
                                    Dictionary<string, string> postDict = defPostDict,
                                    int timeout = defTimeout,
                                    string postDataStr = defPostDataStr,
                                    int readWriteTimeout = defReadWriteTimeout)
    {
        //CookieCollection parsedCookies;

        HttpWebResponse resp = null;

        HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);

        req.AllowAutoRedirect = true;
        req.Accept = "*/*";

        //req.ContentType = "text/plain";

        //const string gAcceptLanguage = "en-US"; // zh-CN/en-US
        //req.Headers["Accept-Language"] = gAcceptLanguage;

        req.KeepAlive = true;

        req.UserAgent = gUserAgent;

        req.Headers["Accept-Encoding"] = "gzip, deflate";
        //req.AutomaticDecompression = DecompressionMethods.GZip;
        req.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;

        req.Proxy = gProxy;

        if (timeout > 0)
        {
            req.Timeout = timeout;
        }

        if (readWriteTimeout > 0)
        {
            //default ReadWriteTimeout is 300000=300 seconds = 5 minutes !!!
            //too long, so here change to 300000 = 30 seconds
            //for support TimeOut for later StreamReader's ReadToEnd
            req.ReadWriteTimeout = readWriteTimeout;
        }

        if (curCookies != null)
        {
            req.CookieContainer = new CookieContainer();
            req.CookieContainer.PerDomainCapacity = 40; // following will exceed max default 20 cookie per domain
            req.CookieContainer.Add(curCookies);
        }

        if ((headerDict != null) && (headerDict.Count > 0))
        {
            foreach (string header in headerDict.Keys)
            {
                string headerValue = "";
                if (headerDict.TryGetValue(header, out headerValue))
                {
                    string lowecaseHeader = header.ToLower();
                    // following are allow the caller overwrite the default header setting
                    if (lowecaseHeader == "referer")
                    {
                        req.Referer = headerValue;
                    }
                    else if (
                            (lowecaseHeader == "allow-autoredirect") ||
                            (lowecaseHeader == "allowautoredirect") ||
                            (lowecaseHeader == "allow autoredirect")
                            )
                    {
                        bool isAllow = false;
                        if (bool.TryParse(headerValue, out isAllow))
                        {
                            req.AllowAutoRedirect = isAllow;
                        }
                    }
                    else if (lowecaseHeader == "accept")
                    {
                        req.Accept = headerValue;
                    }
                    else if (
                            (lowecaseHeader == "keep-alive") ||
                            (lowecaseHeader == "keepalive") ||
                            (lowecaseHeader == "keep alive")
                            )
                    {
                        bool isKeepAlive = false;
                        if (bool.TryParse(headerValue, out isKeepAlive))
                        {
                            req.KeepAlive = isKeepAlive;
                        }
                    }
                    else if (
                            (lowecaseHeader == "accept-language") ||
                            (lowecaseHeader == "acceptlanguage") ||
                            (lowecaseHeader == "accept language")
                            )

                    {
                        req.Headers["Accept-Language"] = headerValue;
                    }
                    else if (
                            (lowecaseHeader == "user-agent") ||
                            (lowecaseHeader == "useragent") ||
                            (lowecaseHeader == "user agent")
                            )
                    {
                        req.UserAgent = headerValue;
                    }
                    else if (
                            (lowecaseHeader == "content-type") ||
                            (lowecaseHeader == "contenttype") ||
                            (lowecaseHeader == "content type")
                            )
                    {
                        req.ContentType = headerValue;
                    }
                    else
                    {
                        req.Headers[header] = headerValue;
                    }
                }
                else
                {
                    break;
                }
            }
        }

        if (((postDict != null) && (postDict.Count > 0)) || (!string.IsNullOrEmpty(postDataStr)))
        {
            req.Method = "POST";
            if (req.ContentType == null)
            {
                req.ContentType = "application/x-www-form-urlencoded";
            }

            if ((postDict != null) && (postDict.Count > 0))
            {
                postDataStr = _quoteParas(postDict);
            }
                        
            //byte[] postBytes = Encoding.GetEncoding("utf-8").GetBytes(postData);
            byte[] postBytes = Encoding.UTF8.GetBytes(postDataStr);
            req.ContentLength = postBytes.Length;

            try
            {
                Stream postDataStream = req.GetRequestStream();
                postDataStream.Write(postBytes, 0, postBytes.Length);
                postDataStream.Close();
            }
            catch (WebException webEx)
            {
                //for prev has set ReadWriteTimeout
                //so here also may timeout
                if (webEx.Status == WebExceptionStatus.Timeout)
                {
                    req = null;
                }
            }
        }
        else
        {
            req.Method = "GET";
        }

        if (req != null)
        {
            //may timeout, has fixed in:
            //http://www.crifan.com/fixed_problem_sometime_httpwebrequest_getresponse_timeout/
            try
            {
                resp = (HttpWebResponse)req.GetResponse();
                updateLocalCookies(resp.Cookies, ref curCookies);
            }
            catch (WebException webEx)
            {
                if (webEx.Status == WebExceptionStatus.Timeout)
                {
                    resp = null;
                }
            }
        }
        
        return resp;
    }

#if USE_GETURLRESPONSE_BW
    private void getUrlResponse_bw(string url,
                                    Dictionary<string, string> headerDict = defHeaderDict,
                                    Dictionary<string, string> postDict = defPostDict,
                                    int timeout = defTimeout,
                                    string postDataStr = defPostDataStr,
                                    int readWriteTimeout = defReadWriteTimeout)
    {
        // Create a background thread
        BackgroundWorker bgwGetUrlResp = new BackgroundWorker();
        bgwGetUrlResp.DoWork += new DoWorkEventHandler(bgwGetUrlResp_DoWork);
        bgwGetUrlResp.RunWorkerCompleted += new RunWorkerCompletedEventHandler( bgwGetUrlResp_RunWorkerCompleted );

        //init
        bNotCompleted_resp = true;
            
        // run in another thread
        object paraObj = new object[] { url, headerDict, postDict, timeout, postDataStr, readWriteTimeout };
        bgwGetUrlResp.RunWorkerAsync(paraObj);
    }

    private void bgwGetUrlResp_DoWork(object sender, DoWorkEventArgs e)
    {
        object[] paraObj = (object[])e.Argument;
        string url = (string)paraObj[0];
        Dictionary<string, string> headerDict = (Dictionary<string, string>)paraObj[1];
        Dictionary<string, string> postDict = (Dictionary<string, string>)paraObj[2];
        int timeout = (int)paraObj[3];
        string postDataStr = (string)paraObj[4];
        int readWriteTimeout = (int)paraObj[5];

        e.Result = _getUrlResponse(url, headerDict, postDict, timeout, postDataStr, readWriteTimeout);
    }

    //void m_bgWorker_ProgressChanged(object sender, ProgressChangedEventArgs e)
    //{
    //    bRespNotCompleted = true;
    //}

    private void bgwGetUrlResp_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
    {
        // The background process is complete. We need to inspect
        // our response to see if an error occurred, a cancel was
        // requested or if we completed successfully.

        // Check to see if an error occurred in the
        // background process.
        if (e.Error != null)
        {
            //MessageBox.Show(e.Error.Message);
            return;
        }

        // Check to see if the background process was cancelled.
        if (e.Cancelled)
        {
            //MessageBox.Show("Cancelled ...");
        }
        else
        {
            bNotCompleted_resp = false;

            // Everything completed normally.
            // process the response using e.Result
            //MessageBox.Show("Completed...");
            gCurResp = (HttpWebResponse)e.Result;
        }
    }
#endif


    private void getUrlRespStreamBytes_bw(ref Byte[] respBytesBuf,
                                string url,
                                Dictionary<string, string> headerDict,
                                Dictionary<string, string> postDict,
                                int timeout,
                                Action<int> funcUpdateProgress)
    {
        // Create a background thread
        gBgwDownload = new BackgroundWorker();
        gBgwDownload.DoWork += bgwDownload_DoWork;
        gBgwDownload.RunWorkerCompleted += bgwDownload_RunWorkerCompleted;
        gBgwDownload.WorkerReportsProgress = true;
        gBgwDownload.ProgressChanged += bgwDownload_ProgressChanged;

        //init
        bNotCompleted_download = true;
        gFuncUpdateProgress = funcUpdateProgress;
        
        // run in another thread
        object paraObj = new object[] {respBytesBuf, url, headerDict, postDict, timeout};
        gBgwDownload.RunWorkerAsync(paraObj);
    }

    private void bgwDownload_ProgressChanged(object sender, ProgressChangedEventArgs e)
    {
        if (gFuncUpdateProgress != null)
        {
            // This function fires on the UI thread so it's safe to edit
            // the UI control directly, no funny business with Control.Invoke.
            // Update the progressBar with the integer supplied to us from the
            // ReportProgress() function.  Note, e.UserState is a "tag" property
            // that can be used to send other information from the
            // BackgroundThread to the UI thread.

            gFuncUpdateProgress(e.ProgressPercentage);
        }
    }

    private void bgwDownload_DoWork(object sender, DoWorkEventArgs e)
    {
    //    // The sender is the BackgroundWorker object we need it to
    //    // report progress and check for cancellation.
    //    BackgroundWorker gBgwDownload = sender as BackgroundWorker;

        object[] paraObj = (object[])e.Argument;
        Byte[] respBytesBuf = (Byte[])paraObj[0];
        string url = (string)paraObj[1];
        Dictionary<string, string> headerDict = (Dictionary<string, string>)paraObj[2];
        Dictionary<string, string> postDict = (Dictionary<string, string>)paraObj[3];
        int timeout = (int)paraObj[4];

        //e.Result = _getUrlRespStreamBytes(ref respBytesBuf, url, headerDict, postDict, timeout);
        

        int curReadoutLen;
        int realReadoutLen = 0;
        int curBufPos = 0;
        
        long totalLength = 0;
        long currentLength = 0;

        try
        {
            //HttpWebResponse resp = getUrlResponse(url, headerDict, postDict, timeout);
            HttpWebResponse resp = getUrlResponse(url, headerDict, postDict);
            long expectReadoutLen = resp.ContentLength;

            totalLength = expectReadoutLen;
            currentLength = 0;

            Stream binStream = resp.GetResponseStream();
            //int streamDataLen  = (int)binStream.Length; // erro: not support seek operation

            do
            {
                //let up layer update its UI, otherwise up layer UI will no response during this func exec time
                //now has make this function to call by backgroundworker, so not need this to update UI
                //System.Windows.Forms.Application.DoEvents();

                // here download logic is:
                // once request, return some data
                // request multiple time, until no more data
                curReadoutLen = binStream.Read(respBytesBuf, curBufPos, (int)expectReadoutLen);
                if (curReadoutLen > 0)
                {
                    curBufPos += curReadoutLen;

                    currentLength = curBufPos;

                    expectReadoutLen = expectReadoutLen - curReadoutLen;

                    realReadoutLen += curReadoutLen;

                    int currentPercent = (int)((currentLength * 100) / totalLength);
                    
                    if (currentPercent < 0)
                    {
                        currentPercent = 0;
                    }

                    if (currentPercent > 100)
                    {
                        currentPercent = 100;
                    }

                    gBgwDownload.ReportProgress(currentPercent);
                }
            } while (curReadoutLen > 0);
        }
        catch (Exception ex)
        {
            string errorMessage = ex.Message;
            realReadoutLen = -1;
        }

        //return realReadoutLen;
        
        e.Result = realReadoutLen;
        //gBgwDownload.ReportProgress(100);
    }

    private void bgwDownload_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
    {
        // The background process is complete. We need to inspect
        // our response to see if an error occurred, a cancel was
        // requested or if we completed successfully.

        // Check to see if an error occurred in the
        // background process.
        if (e.Error != null)
        {
            //MessageBox.Show(e.Error.Message);
            return;
        }

        // Check to see if the background process was cancelled.
        if (e.Cancelled)
        {
            //MessageBox.Show("Cancelled ...");
        }
        else
        {
            bNotCompleted_download = false;

            // Everything completed normally.
            // process the response using e.Result
            //MessageBox.Show("Completed...");
            gRealReadoutLen = (int)e.Result;
        }
    }
]]>
    </programlisting>
    <para></para>
</sect1>
    
</preface>
